# Smart Review System - Subagents vs Skills 詳細比較

*バージョン: v4.0.0*
*最終更新: 2025年11月17日*

## 📊 技術的な詳細比較

### 1. コンテキスト管理

| 観点 | Subagents | Skills | 評価 |
|------|-----------|--------|------|
| **トークン消費** | 全てのSubagentが常に読み込まれる | プログレッシブ・ディスクロージャー：使用時のみ読み込み | Skills ✅ |
| **コンテキスト共有** | 同一セッション内で共有 | 同一セッション内で共有 | 同等 |
| **状態管理** | 明示的に変数で管理 | Claudeが暗黙的に管理 | Subagents ✅ |

### 2. メモリー効率

| 観点 | Subagents | Skills | 評価 |
|------|-----------|--------|------|
| **初期ロード** | 全定義を一度に読み込み（~2000トークン/agent × 4 = 8000トークン） | YAMLフロントマターのみ（~100トークン/skill × 4 = 400トークン） | Skills ✅✅ |
| **実行時** | 既にコンテキスト内 | 必要なSkillのみ本体を読み込み | Skills ✅ |
| **大規模化** | 10個のSubagents = 20,000トークン | 10個のSkills = 1,000トークン（初期）+ 必要分のみ | Skills ✅✅ |

### 3. 学習・適応

| 観点 | Subagents | Skills | 評価 |
|------|-----------|--------|------|
| **パターン学習** | セッション内のみ | Skills定義ファイルに蓄積可能 | Skills ✅ |
| **カスタマイズ** | セッションごとに指示が必要 | SKILL.mdを更新すれば永続的 | Skills ✅ |
| **チーム学習** | 困難 | Git管理で共有・進化させやすい | Skills ✅ |

### 4. 制御性

| 観点 | Subagents | Skills | 評価 |
|------|-----------|--------|------|
| **実行順序** | 完全に制御可能 | Claudeの判断に依存 | Subagents ✅✅ |
| **エラーハンドリング** | 明示的に処理可能 | Claudeに依存 | Subagents ✅ |
| **条件分岐** | プログラマティックに制御 | Claudeの判断 | Subagents ✅ |
| **結果統合** | 確実に取得・統合 | 不確実 | Subagents ✅✅ |

## 🎯 トークン消費の実測シミュレーション

### シナリオ: 100ファイルのプロジェクトレビュー

#### Subagentsアプローチ

```
初期ロード:
├─ smart-review コマンド: 1,500トークン
├─ security-analyzer: 2,000トークン
├─ super-debugger: 2,000トークン
├─ code-reviewer: 1,800トークン
└─ doc-updater: 1,500トークン
合計: 8,800トークン

実行中（各ファイル分析）:
├─ ファイル内容: 100ファイル × 500トークン = 50,000トークン
├─ 分析プロンプト: 100 × 200トークン = 20,000トークン
└─ 結果生成: 5,000トークン
合計: 75,000トークン

総計: 83,800トークン
```

#### Skillsアプローチ

```
初期ロード（YAMLのみ）:
├─ smart-review-security: 100トークン
├─ smart-review-debug: 100トークン
├─ smart-review-quality: 100トークン
└─ smart-review-docs: 100トークン
合計: 400トークン

実行時（必要なSkillのみ本体を読み込み）:
├─ セキュリティ分析が必要 → security Skill本体: 2,000トークン
├─ ファイル分析: 50,000トークン
├─ 分析プロンプト: 20,000トークン
└─ 結果生成: 5,000トークン
合計: 77,000トークン

総計: 77,400トークン

削減率: 7.6% (6,400トークン削減)
```

### シナリオ2: 差分レビュー（3ファイルのみ）

#### Subagentsアプローチ

```
初期ロード: 8,800トークン（変わらず）
実行: 3ファイル × 500 + 分析 = 2,500トークン
総計: 11,300トークン
```

#### Skillsアプローチ

```
初期ロード: 400トークン
セキュリティSkillのみ使用: 2,000トークン
実行: 2,500トークン
総計: 4,900トークン

削減率: 56.6% (6,400トークン削減) ✅✅
```

## 💡 重要な発見

### Skills の圧倒的なメリット

1. **小規模タスクで劇的に効率的**
   - 差分レビューなど、一部のSkillのみ使う場合
   - トークン消費が50%以上削減

2. **スケーラビリティ**
   - Skillを10個、20個と増やしても初期コストは低い
   - 実際に使うSkillのみロード

3. **長期的な学習効果**
   - SKILL.mdに検出パターンを追加していける
   - チーム全体で知識が蓄積

### Subagents の重要なメリット

1. **確実性**
   - 実行順序が保証される
   - 結果統合が確実

2. **オーケストレーション**
   - Phase 1 → Phase 2 の段階的実行
   - 条件分岐（Critical問題があれば中断など）

3. **エラーハンドリング**
   - 明示的な制御が可能

## 🔄 ハイブリッドアプローチ（推奨）

両方の利点を組み合わせた最適解を提案します。

### アーキテクチャ

```
.claude/
├── commands/
│   ├── smart-review.md          # 軽量オーケストレーター
│   ├── review-changes.md        # 差分レビュー用
│   └── review-security.md       # セキュリティのみ
├── skills/                      # ★ Skills として実装
│   ├── smart-review-security/
│   │   ├── SKILL.md            # 本体（2000トークン）
│   │   ├── patterns.json
│   │   └── cwe-mapping.json
│   ├── smart-review-debug/
│   │   ├── SKILL.md
│   │   └── checklist.md
│   ├── smart-review-quality/
│   │   ├── SKILL.md
│   │   └── metrics.json
│   └── smart-review-docs/
│       ├── SKILL.md
│       └── templates/
└── CLAUDE.md                    # オーケストレーション指示
```

### 実装：軽量オーケストレーター

**`.claude/commands/smart-review.md`**

```markdown
---
description: 包括的コードレビュー（Skills自動オーケストレーション）
---

# Smart Review System - Orchestrated

このコマンドは、適切なSkillsを順次使用してコードレビューを実行します。

## 実行指示

以下の順序で、対応するSkillを使用して分析してください：

### Phase 1: Critical/High Priority（必須・順次）

**ステップ 1: セキュリティ分析**
- **使用Skill**: smart-review-security
- **タイミング**: 最優先で実行
- **出力**: JSON形式でセキュリティ問題を記録

[smart-review-security Skillを使用]
対象ファイル: {files}
JSON形式で出力してください。

実行完了後、次のステップに進んでください。

---

**ステップ 2: デバッグ分析**
- **使用Skill**: smart-review-debug
- **タイミング**: セキュリティ分析の後
- **出力**: JSON形式でバグを記録

[smart-review-debug Skillを使用]
対象ファイル: {files}
JSON形式で出力してください。

---

### Phase 2: Medium/Low Priority（並列可能）

**ステップ 3: 品質分析**
[smart-review-quality Skillを使用]
対象ファイル: {files}

**ステップ 4: ドキュメント分析**
[smart-review-docs Skillを使用]
対象ファイル: {files}

---

### 統合

全てのSkill実行が完了したら、以下を生成してください：

1. **統合レポート**
   - 各カテゴリーの問題数
   - 重要度別の集計
   
2. **TODOリスト（Markdown）**
   ```markdown
   # Smart Review TODO List
   
   生成日時: {timestamp}
   分析ファイル数: {count}
   
   ## Critical Priority ({count}件)
   - [ ] 🔴 [Security] 問題
     - **場所**: file:line
     - **推奨**: 修正方法
     - **工数**: 30m
   
   ## High Priority ({count}件)
   ...
   ```

## 重要な原則

- **順序厳守**: Phase 1 → Phase 2 の順序を守る
- **Skill明示**: 各ステップで必ずSkill名を明示的に指定
- **結果保持**: 各Skillの出力を保持し、最後に統合
- **JSON形式**: 各Skillの出力はJSON形式で取得
```

### 実装：CLAUDE.md（プロジェクトレベル）

**`CLAUDE.md`**

```markdown
# Smart Review System - Project Configuration

このプロジェクトでは、コードレビューに以下のSkillsを使用します。

## 利用可能なSkills

### 1. smart-review-security (Critical)
- **自動起動条件**: 「セキュリティ」「脆弱性」「XSS」「SQLi」などのキーワード
- **使用タイミング**: 常に最優先で実行
- **出力**: JSON形式

### 2. smart-review-debug (High)
- **自動起動条件**: 「バグ」「デバッグ」「エラー」「null」などのキーワード
- **使用タイミング**: セキュリティ分析の後
- **出力**: JSON形式

### 3. smart-review-quality (Medium)
- **自動起動条件**: 「品質」「複雑度」「リファクタリング」などのキーワード
- **使用タイミング**: Phase 2で実行
- **出力**: JSON形式

### 4. smart-review-docs (Low)
- **自動起動条件**: 「ドキュメント」「コメント」「JSDoc」などのキーワード
- **使用タイミング**: Phase 2で実行
- **出力**: JSON形式

## Skills自動選択のヒント

各Skillの description フィールドには、以下のトリガーワードが含まれています：

- **security**: 「セキュリティ脆弱性」「XSS」「SQLインジェクション」
- **debug**: 「バグ」「ロジックエラー」「null参照」
- **quality**: 「コード品質」「複雑度」「保守性」
- **docs**: 「ドキュメント」「JSDoc」「コメント」

## オーケストレーション

スラッシュコマンドを実行する際、各Skillを明示的に指定することで：
1. 実行順序を保証
2. 結果の確実な統合
3. エラーハンドリング

一方で、自然言語での問い合わせには、Claudeが適切なSkillを自動選択します。
```

### Skills実装例

**`.claude/skills/smart-review-security/SKILL.md`**

```markdown
---
name: "smart-review-security"
description: "セキュリティ脆弱性を検出します。XSS、SQLインジェクション、コマンドインジェクション、認証・認可の問題、機密情報の露出などを分析する際に使用してください。Critical/High優先度の問題を検出します。"
---

# Smart Review - Security Analysis Skill

## 概要
このSkillは、コードのセキュリティ脆弱性を包括的に分析します。

## 自動起動トリガー

以下のようなリクエストで自動的に起動されます：
- 「セキュリティレビューをお願いします」
- 「XSS脆弱性をチェック」
- 「このコードに認証の問題はありますか？」
- 「SQLインジェクションのリスクは？」

## 分析範囲

### 1. XSS (CWE-79)
- innerHTML への直接代入
- dangerouslySetInnerHTML の使用
- 未エスケープのユーザー入力

**検出パターン**: patterns.json参照

### 2. SQLインジェクション (CWE-89)
- 文字列連結によるクエリ構築
- プリペアドステートメント未使用

### 3. コマンドインジェクション (CWE-78)
- eval() の使用
- 検証なしのコマンド実行

### 4. 認証・認可
- JWT署名検証の欠如
- セッション管理の問題

### 5. 機密情報
- ハードコードされた認証情報
- ログへの機密情報出力

## 実行プロセス

1. **ファイル読み込み**
   - 対象ファイルを順次解析
   
2. **パターンマッチング**
   - patterns.json の定義を使用
   - 正規表現 + セマンティック分析

3. **脆弱性評価**
   - 重要度判定（Critical/High/Medium/Low）
   - CWEマッピング
   - 攻撃シナリオ想定

4. **修正推奨生成**
   - 具体的な修正方法
   - コード例
   - 自動修正可否

## 出力形式（必須）

**必ずこの形式で出力してください**：

```json
{
  "skill": "smart-review-security",
  "timestamp": "2025-11-17T12:00:00Z",
  "summary": "セキュリティ分析完了: 3件のCritical問題を検出",
  "filesAnalyzed": 15,
  "issuesFound": 5,
  "issues": [
    {
      "severity": "critical",
      "type": "XSS",
      "cwe": "CWE-79",
      "file": "src/index.js",
      "line": 42,
      "code": "element.innerHTML = userInput",
      "description": "ユーザー入力が直接DOMに挿入されています",
      "impact": "攻撃者が任意のJavaScriptコードを実行可能",
      "recommendation": "textContent を使用するか、DOMPurify でサニタイズしてください",
      "example": "element.textContent = userInput; // 安全",
      "autoFixable": true,
      "estimatedEffort": "30m",
      "references": [
        "https://owasp.org/www-community/attacks/xss/",
        "https://cwe.mitre.org/data/definitions/79.html"
      ]
    }
  ]
}
```

## パターン定義の参照

詳細な検出パターンは同じディレクトリの `patterns.json` を参照してください。

## 継続的改善

- 新しい脆弱性パターンが見つかったら `patterns.json` に追加
- 誤検出があれば除外ルールを追加
- チームでナレッジを蓄積

## メモリー効率

このSkillは、プログレッシブ・ディスクロージャーにより：
- 初期ロード: 約100トークン（YAMLのみ）
- 実行時: 約2,000トークン（本体 + patterns.json）
- 未使用時: トークン消費なし

合計4つのSkillがあっても、初期ロードは400トークンのみ。
実際に使用するSkillだけが本体をロードします。
```

## 📈 実装比較表

### アプローチ1: Pure Subagents

```
メリット:
✅ 実行順序の完全な制御
✅ 確実なエラーハンドリング
✅ プログラマティックな条件分岐

デメリット:
❌ 初期トークン消費が大きい（8,800トークン）
❌ スケールしにくい
❌ 学習効果が低い
```

### アプローチ2: Pure Skills

```
メリット:
✅ 初期トークン消費が小さい（400トークン）
✅ スケーラブル
✅ 長期的な学習効果

デメリット:
❌ 実行順序の保証が難しい
❌ 結果統合が不確実
❌ エラーハンドリングが困難
```

### アプローチ3: ハイブリッド（推奨）✨

```
メリット:
✅ 初期トークン消費が小さい（400トークン）
✅ 実行順序を指示で制御
✅ スケーラブル
✅ 長期的な学習効果
✅ Claudeの自動判断も活用可能

実装:
- Skills として実装
- スラッシュコマンドで明示的に指示
- CLAUDE.md でオーケストレーション定義
```

## 🎯 推奨実装：ハイブリッドアプローチ

### 理由

1. **トークン効率**: Skillsのプログレッシブ・ディスクロージャー
2. **制御性**: スラッシュコマンドによる明示的指示
3. **柔軟性**: 自然言語での問い合わせにも対応
4. **学習効果**: SKILL.mdの継続的改善
5. **スケーラビリティ**: 10個、20個とSkillを増やしても効率的

### 実行例

#### 明示的オーケストレーション

```bash
claude
> /smart-review

# → スラッシュコマンドが各Skillを明示的に呼び出し
# → 順序保証、結果統合が確実
```

#### 自動選択

```bash
claude
> このプロジェクトのセキュリティをチェックしてください

# → Claudeが smart-review-security Skillを自動選択
# → トークン効率的
```

#### 差分レビュー

```bash
claude
> 最近変更したファイルをレビューしてください

# → 変更ファイルのみを対象
# → 必要なSkillだけロード（トークン削減）
```

## 💾 メモリーと学習の効果

### 短期メモリー（セッション内）

**Subagents**: 同等
**Skills**: 同等

### 長期メモリー（セッション間）

**Skills の優位性**:

1. **パターンの蓄積**
   ```json
   // patterns.json に新しいパターンを追加
   {
     "xss": [
       {
         "pattern": "v-html.*=.*user",
         "description": "Vue.js の v-html でユーザー入力",
         "severity": "high"
       }
     ]
   }
   ```

2. **ナレッジの共有**
   - SKILL.mdをGit管理
   - チーム全体で改善を蓄積
   - プロジェクト間で再利用

3. **進化するSkill**
   - 新しい脆弱性パターンを追加
   - 誤検出を除外ルールで対応
   - 検出精度が向上

## 🚀 実装ステップ（ハイブリッド版）

### Week 1: 基盤構築 + Security Skill

1. ディレクトリ構造作成
2. smart-review コマンド作成
3. smart-review-security Skill実装
4. patterns.json作成
5. テスト

### Week 2: Debug + Quality Skills

1. smart-review-debug Skill実装
2. smart-review-quality Skill実装
3. 統合テスト

### Week 3: Documentation + 統合

1. smart-review-docs Skill実装
2. オーケストレーション調整
3. CLAUDE.md最適化

### Week 4: 最適化 + ドキュメント

1. トークン消費の測定・最適化
2. エラーハンドリング強化
3. ユーザードキュメント作成
4. サンプルプロジェクトでの検証

## 📊 ROI分析（投資対効果）

### トークン削減効果（年間）

**前提**:
- 1日10回のレビュー実行
- 年間営業日: 250日
- 合計: 2,500回/年

**Subagents**: 2,500回 × 8,800トークン = 22,000,000トークン/年
**Skills**: 2,500回 × 400トークン（初期）+ 実行時分 ≈ 20,000,000トークン/年

**削減**: 約2,000,000トークン/年（9%削減）

**差分レビューの場合**:
**Subagents**: 2,500回 × 11,300トークン = 28,250,000トークン/年
**Skills**: 2,500回 × 4,900トークン = 12,250,000トークン/年

**削減**: 約16,000,000トークン/年（56%削減）✨

### 学習効果（定性的）

- パターンの蓄積により検出精度が向上
- 誤検出の減少
- チームナレッジの共有
- プロジェクト間での再利用

## ✅ 最終推奨

**ハイブリッドアプローチ（Skills + 明示的オーケストレーション）**

### 理由まとめ

1. **トークン効率**: 40-50%削減（差分レビュー時）
2. **制御性**: スラッシュコマンドで順序保証
3. **柔軟性**: 自動選択も活用可能
4. **学習効果**: 長期的な品質向上
5. **スケーラビリティ**: Skillを増やしても効率的
6. **元の設計の尊重**: オーケストレーション概念を維持

### 次のステップ

実装を開始する場合：

1. **プロトタイプSkillの作成** 
   - smart-review-security Skillの完全実装
   - patterns.json作成
   - 動作確認

2. **オーケストレーターの作成**
   - smart-review.md スラッシュコマンド
   - CLAUDE.md設定

3. **統合テスト**
   - サンプルプロジェクトでの検証
   - トークン消費の実測

どこから始めましょうか？

---

*作成日: 2025年11月17日*
*バージョン: v4.0.0*
*最終推奨: ハイブリッドアプローチ（Skills + オーケストレーション）*
